import sqlite3, json, os, re
from Levenshtein import distance
import logging

DB_PATH = "/opt/aura-assistant/db.sqlite3"

ENTITIES_DDL = """
CREATE TABLE IF NOT EXISTS entities (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER NOT NULL,
  type TEXT NOT NULL,
  title TEXT,
  content TEXT,
  parent_id INTEGER,
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  meta TEXT,
  UNIQUE(user_id, type, title, parent_id)
);
"""

def get_conn():
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row
    conn.isolation_level = None
    return conn

def init_db():
    conn = get_conn()
    with conn:
        conn.execute(ENTITIES_DDL)
    conn.close()

def _get_or_create_list(conn, user_id, list_name):
    try:
        cur = conn.cursor()
        cur.execute("""SELECT id FROM entities WHERE user_id=? AND type='list' AND title=? LIMIT 1""", (user_id, list_name))
        row = cur.fetchone()
        if row:
            logging.info(f"List '{list_name}' already exists for user {user_id}, ID: {row[0]}")
            return row[0]
        cur.execute("""INSERT INTO entities (user_id, type, title) VALUES (?, 'list', ?)""", (user_id, list_name))
        list_id = cur.lastrowid
        logging.info(f"Created list '{list_name}' for user {user_id}, ID: {list_id}")
        return list_id
    except sqlite3.Error as e:
        logging.error(f"SQLite error in _get_or_create_list: {e}")
        raise

def create_list(conn, user_id, list_name):
    return _get_or_create_list(conn, user_id, list_name)

def rename_list(conn, user_id, old_name, new_name):
    try:
        cur = conn.cursor()
        cur.execute("""SELECT id FROM entities WHERE user_id=? AND type='list' AND title=? LIMIT 1""", (user_id, old_name))
        row = cur.fetchone()
        if not row:
            logging.info(f"No list '{old_name}' found for user {user_id}")
            return 0
        cur.execute("""SELECT id FROM entities WHERE user_id=? AND type='list' AND title=? LIMIT 1""", (user_id, new_name))
        if cur.fetchone():
            logging.info(f"List '{new_name}' already exists for user {user_id}")
            return 0
        cur.execute("""UPDATE entities SET title=? WHERE id=?""", (new_name, row["id"]))
        logging.info(f"Renamed list '{old_name}' to '{new_name}' for user {user_id}")
        return 1
    except sqlite3.Error as e:
        logging.error(f"SQLite error in rename_list: {e}")
        return 0

def find_list(conn, user_id, list_name):
    try:
        cur = conn.cursor()
        cur.execute("""SELECT id, title FROM entities WHERE user_id=? AND type='list' AND title=? LIMIT 1""", (user_id, list_name))
        return cur.fetchone()
    except sqlite3.Error as e:
        logging.error(f"SQLite error in find_list: {e}")
        return None

def get_all_lists(conn, user_id):
    try:
        cur = conn.cursor()
        cur.execute("""SELECT title FROM entities WHERE user_id=? AND type='list' AND (meta IS NULL OR json_extract(meta, '$.deleted') IS NOT TRUE) ORDER BY title ASC""", (user_id,))
        return [row["title"] for row in cur.fetchall()]
    except sqlite3.Error as e:
        logging.error(f"SQLite error in get_all_lists: {e}")
        return []

def add_task(conn, user_id, list_name, title):
    cur = conn.cursor()
    # Check if list exists
    cur.execute("SELECT id FROM entities WHERE user_id = ? AND type = 'list' AND title = ?", (user_id, list_name))
    list_id = cur.fetchone()
    if not list_id:
        logging.info(f"No list '{list_name}' found for user {user_id}")
        return None
    list_id = list_id[0]
    # Check if task already exists and is not marked as done
    cur.execute("""
        SELECT id FROM entities 
        WHERE user_id = ? AND type = 'task' AND title = ? AND parent_id = ?
        AND (meta IS NULL OR json_extract(meta, '$.status') != 'done')
    """, (user_id, title, list_id))
    existing_task = cur.fetchone()
    if existing_task:
        # If task exists but is marked done, restore it by clearing meta
        cur.execute("""
            UPDATE entities 
            SET meta = NULL 
            WHERE id = ?
        """, (existing_task[0],))
        conn.commit()
        logging.info(f"Restored task '{title}' in list '{list_name}' for user {user_id}")
        return existing_task[0]
    # Insert new task
    cur.execute("INSERT INTO entities (user_id, type, title, parent_id) VALUES (?, ?, ?, ?)", 
                (user_id, 'task', title, list_id))
    task_id = cur.lastrowid
    conn.commit()
    logging.info(f"Added new task '{title}' to list '{list_name}' for user {user_id}")
    return task_id

def update_task(conn, user_id, list_name, old_title, new_title):
    try:
        cur = conn.cursor()
        cur.execute("""SELECT id FROM entities WHERE user_id=? AND type='list' AND title=? LIMIT 1""", (user_id, list_name))
        row = cur.fetchone()
        if not row:
            logging.info(f"No list '{list_name}' found for user {user_id}")
            return 0
        list_id = row["id"]
        cur.execute("""SELECT id FROM entities WHERE user_id=? AND type='task' AND parent_id=? AND title=? LIMIT 1""", (user_id, list_id, old_title))
        task = cur.fetchone()
        if not task:
            logging.info(f"No task '{old_title}' found in list '{list_name}' for user {user_id}")
            return 0
        cur.execute("""SELECT id FROM entities WHERE user_id=? AND type='task' AND parent_id=? AND title=? LIMIT 1""", (user_id, list_id, new_title))
        if cur.fetchone():
            logging.info(f"Task '{new_title}' already exists in list '{list_name}' for user {user_id}")
            return 0
        cur.execute("""UPDATE entities SET title=? WHERE id=?""", (new_title, task["id"]))
        logging.info(f"Updated task '{old_title}' to '{new_title}' in list '{list_name}' for user {user_id}")
        return 1
    except sqlite3.Error as e:
        logging.error(f"SQLite error in update_task: {e}")
        return 0

def update_task_by_index(conn, user_id, list_name, index, new_title):
    try:
        cur = conn.cursor()
        cur.execute("""SELECT id FROM entities WHERE user_id=? AND type='list' AND title=? LIMIT 1""", (user_id, list_name))
        row = cur.fetchone()
        if not row:
            logging.info(f"No list '{list_name}' found for user {user_id}")
            return 0, None
        list_id = row["id"]
        cur.execute("""SELECT id, title FROM entities WHERE user_id=? AND type='task' AND parent_id=? AND (meta IS NULL OR json_extract(meta, '$.deleted') IS NOT TRUE AND json_extract(meta, '$.status') != 'done') ORDER BY created_at ASC""", 
                    (user_id, list_id))
        tasks = cur.fetchall()
        if not tasks or index < 1 or index > len(tasks):
            logging.info(f"Invalid index {index} for list '{list_name}' for user {user_id}")
            return 0, None
        chosen = tasks[index - 1]
        task_id, old_title = chosen["id"], chosen["title"]
        cur.execute("""SELECT id FROM entities WHERE user_id=? AND type='task' AND parent_id=? AND title=? LIMIT 1""", (user_id, list_id, new_title))
        if cur.fetchone():
            logging.info(f"Task '{new_title}' already exists in list '{list_name}' for user {user_id}")
            return 0, None
        cur.execute("""UPDATE entities SET title=? WHERE id=?""", (new_title, task_id))
        logging.info(f"Updated task '{old_title}' to '{new_title}' by index {index} in list '{list_name}' for user {user_id}")
        return 1, old_title
    except sqlite3.Error as e:
        logging.error(f"SQLite error in update_task_by_index: {e}")
        return 0, None

def get_list_tasks(conn, user_id, list_name):
    try:
        cur = conn.cursor()
        cur.execute("""SELECT id FROM entities WHERE user_id=? AND type='list' AND title=? LIMIT 1""", (user_id, list_name))
        row = cur.fetchone()
        if not row:
            logging.info(f"No list '{list_name}' found for user {user_id}")
            return []
        list_id = row["id"]
        cur.execute("""SELECT title FROM entities WHERE user_id=? AND type='task' AND parent_id=? AND (meta IS NULL OR json_extract(meta, '$.deleted') IS NOT TRUE AND json_extract(meta, '$.status') != 'done') ORDER BY created_at ASC""", 
                    (user_id, list_id))
        tasks = [(i+1, r["title"]) for i, r in enumerate(cur.fetchall())]
        logging.info(f"Retrieved {len(tasks)} tasks for list '{list_name}' for user {user_id}")
        return tasks
    except sqlite3.Error as e:
        logging.error(f"SQLite error in get_list_tasks: {e}")
        return []

def mark_task_done(conn, user_id, list_name, task_title):
    try:
        cur = conn.cursor()
        cur.execute("""SELECT id FROM entities WHERE user_id=? AND type='list' AND title=? LIMIT 1""", (user_id, list_name))
        row = cur.fetchone()
        if not row:
            logging.info(f"No list '{list_name}' found for user {user_id}")
            return 0
        list_id = row["id"]
        cur.execute("""SELECT id, meta FROM entities WHERE user_id=? AND type='task' AND parent_id=? AND title=? LIMIT 1""", (user_id, list_id, task_title))
        task = cur.fetchone()
        if not task:
            logging.info(f"No task '{task_title}' found in list '{list_name}' for user {user_id}")
            return 0
        meta = {}
        if task["meta"]:
            try: meta = json.loads(task["meta"])
            except: meta = {}
        meta["status"] = "done"
        cur.execute("""UPDATE entities SET meta=? WHERE id=?""", (json.dumps(meta, ensure_ascii=False), task["id"]))
        logging.info(f"Marked task '{task_title}' as done in list '{list_name}' for user {user_id}")
        return cur.rowcount
    except sqlite3.Error as e:
        logging.error(f"SQLite error in mark_task_done: {e}")
        return 0

def mark_task_done_fuzzy(conn, user_id, list_name, pattern):
    try:
        if not pattern:
            logging.info(f"No pattern provided for fuzzy mark done in list '{list_name}' for user {user_id}")
            return 0, None
        q = re.sub(r'[^0-9a-zA-Zа-яА-ЯёЁ ]+', ' ', pattern).strip()
        if not q:
            logging.info(f"Invalid pattern after cleaning for fuzzy mark done in list '{list_name}' for user {user_id}")
            return 0, None
        cur = conn.cursor()
        cur.execute("""SELECT id FROM entities WHERE user_id=? AND type='list' AND title=? LIMIT 1""", (user_id, list_name))
        row = cur.fetchone()
        if not row:
            logging.info(f"No list '{list_name}' found for user {user_id}")
            return 0, None
        list_id = row["id"]
        cur.execute("""SELECT id, title, meta FROM entities WHERE user_id=? AND type='task' AND parent_id=? AND (meta IS NULL OR json_extract(meta, '$.deleted') IS NOT TRUE AND json_extract(meta, '$.status') != 'done')""", 
                    (user_id, list_id))
        candidates = [(r["id"], r["title"], r["meta"]) for r in cur.fetchall()]
        if not candidates:
            logging.info(f"No tasks found in list '{list_name}' for user {user_id}")
            return 0, None
        candidates.sort(key=lambda x: distance(x[1].lower(), q.lower()))
        if distance(candidates[0][1].lower(), q.lower()) > len(q) // 2:
            logging.info(f"No close match for pattern '{q}' in list '{list_name}' for user {user_id}")
            return 0, None
        chosen_id, chosen_title, meta = candidates[0]
        try:
            meta = json.loads(meta) if meta else {}
        except:
            meta = {}
        meta["status"] = "done"
        cur.execute("UPDATE entities SET meta=? WHERE id=?", (json.dumps(meta, ensure_ascii=False), chosen_id))
        logging.info(f"Fuzzy marked task '{chosen_title}' as done in list '{list_name}' for user {user_id}")
        return 1, chosen_title
    except sqlite3.Error as e:
        logging.error(f"SQLite error in mark_task_done_fuzzy: {e}")
        return 0, None

def delete_list(conn, user_id, list_name):
    try:
        cur = conn.cursor()
        cur.execute("""SELECT id, meta FROM entities WHERE user_id=? AND type='list' AND title=? LIMIT 1""", (user_id, list_name))
        row = cur.fetchone()
        if not row:
            logging.info(f"No list '{list_name}' found for user {user_id}")
            return 0
        list_id, meta = row["id"], row["meta"]
        try: meta = json.loads(meta) if meta else {}
        except: meta = {}
        meta["deleted"] = True
        cur.execute("UPDATE entities SET meta=? WHERE id=?", (json.dumps(meta, ensure_ascii=False), list_id))
        cur.execute("""SELECT id, meta FROM entities WHERE user_id=? AND type='task' AND parent_id=?""", (user_id, list_id))
        for r in cur.fetchall():
            m = {}
            try: m = json.loads(r["meta"]) if r["meta"] else {}
            except: m = {}
            m["deleted"] = True
            cur.execute("UPDATE entities SET meta=? WHERE id=?", (json.dumps(m, ensure_ascii=False), r["id"]))
        logging.info(f"Deleted list '{list_name}' for user {user_id}")
        return 1
    except sqlite3.Error as e:
        logging.error(f"SQLite error in delete_list: {e}")
        return 0

def delete_task(conn, user_id, list_name, task_title):
    try:
        cur = conn.cursor()
        cur.execute("""SELECT id FROM entities WHERE user_id=? AND type='list' AND title=? LIMIT 1""", (user_id, list_name))
        row = cur.fetchone()
        if not row:
            logging.info(f"No list '{list_name}' found for user {user_id}")
            return 0
        list_id = row["id"]
        cur.execute("""SELECT id, meta FROM entities WHERE user_id=? AND type='task' AND parent_id=? AND title=? LIMIT 1""", (user_id, list_id, task_title))
        t = cur.fetchone()
        if not t:
            logging.info(f"No task '{task_title}' found in list '{list_name}' for user {user_id}")
            return 0
        meta = json.loads(t["meta"]) if t["meta"] else {}
        if meta.get("status") == "done":
            logging.info(f"Task '{task_title}' is already done in list '{list_name}' for user {user_id}")
            return 0
        meta["deleted"] = True
        cur.execute("UPDATE entities SET meta=? WHERE id=?", (json.dumps(meta, ensure_ascii=False), t["id"]))
        logging.info(f"Deleted task '{task_title}' from list '{list_name}' for user {user_id}")
        return 1
    except sqlite3.Error as e:
        logging.error(f"SQLite error in delete_task: {e}")
        return 0

def restore_task(conn, user_id, list_name, task_title):
    try:
        cur = conn.cursor()
        cur.execute("""SELECT id FROM entities WHERE user_id=? AND type='list' AND title=? LIMIT 1""", (user_id, list_name))
        row = cur.fetchone()
        if not row:
            logging.info(f"No list '{list_name}' found for user {user_id}")
            return 0
        list_id = row["id"]
        cur.execute("""SELECT id, meta FROM entities WHERE user_id=? AND type='task' AND parent_id=? AND title=? LIMIT 1""", (user_id, list_id, task_title))
        t = cur.fetchone()
        if not t:
            logging.info(f"No task '{task_title}' found in list '{list_name}' for user {user_id}")
            return 0
        meta = json.loads(t["meta"]) if t["meta"] else {}
        meta["deleted"] = False
        if "status" in meta:
            meta["status"] = "open"
        cur.execute("UPDATE entities SET meta=? WHERE id=?", (json.dumps(meta, ensure_ascii=False), t["id"]))
        logging.info(f"Restored task '{task_title}' in list '{list_name}' for user {user_id}")
        return 1
    except sqlite3.Error as e:
        logging.error(f"SQLite error in restore_task: {e}")
        return 0

def restore_task_fuzzy(conn, user_id, list_name, pattern):
    try:
        if not pattern:
            logging.info(f"No pattern provided for fuzzy restore in list '{list_name}' for user {user_id}")
            return 0, None
        q = re.sub(r'[^0-9a-zA-Zа-яА-ЯёЁ ]+', ' ', pattern).strip()
        if not q:
            logging.info(f"Invalid pattern after cleaning for fuzzy restore in list '{list_name}' for user {user_id}")
            return 0, None
        cur = conn.cursor()
        cur.execute("""SELECT id FROM entities WHERE user_id=? AND type='list' AND title=? LIMIT 1""", (user_id, list_name))
        row = cur.fetchone()
        if not row:
            logging.info(f"No list '{list_name}' found for user {user_id}")
            return 0, None
        list_id = row["id"]
        cur.execute("""SELECT id, title, meta FROM entities WHERE user_id=? AND type='task' AND parent_id=? AND json_extract(meta, '$.deleted') = true""", 
                    (user_id, list_id))
        candidates = [(r["id"], r["title"], r["meta"]) for r in cur.fetchall()]
        if not candidates:
            logging.info(f"No deleted tasks found in list '{list_name}' for user {user_id}")
            return 0, None
        candidates.sort(key=lambda x: distance(x[1].lower(), q.lower()))
        if distance(candidates[0][1].lower(), q.lower()) > len(q) // 2:
            logging.info(f"No close match for pattern '{q}' in list '{list_name}' for user {user_id}")
            return 0, None
        chosen_id, chosen_title, meta = candidates[0]
        try:
            meta = json.loads(meta) if meta else {}
        except:
            meta = {}
        meta["deleted"] = False
        if "status" in meta:
            meta["status"] = "open"
        cur.execute("UPDATE entities SET meta=? WHERE id=?", (json.dumps(meta, ensure_ascii=False), chosen_id))
        logging.info(f"Fuzzy restored task '{chosen_title}' in list '{list_name}' for user {user_id}")
        return 1, chosen_title
    except sqlite3.Error as e:
        logging.error(f"SQLite error in restore_task_fuzzy: {e}")
        return 0, None

def get_completed_tasks(conn, user_id):
    try:
        cur = conn.cursor()
        cur.execute("""SELECT l.title AS list_title, e.title AS task_title, e.meta FROM entities e
                       LEFT JOIN entities l ON l.id = e.parent_id
                       WHERE e.user_id=? AND e.type='task' AND (json_extract(e.meta, '$.status') = 'done' OR json_extract(e.meta, '$.deleted') = true)
                       ORDER BY e.created_at DESC LIMIT 100""", (user_id,))
        tasks = [(row["list_title"], row["task_title"], json.loads(row["meta"]) if row["meta"] else {}) for row in cur.fetchall()]
        logging.info(f"Retrieved {len(tasks)} completed/deleted tasks for user {user_id}")
        return tasks
    except sqlite3.Error as e:
        logging.error(f"SQLite error in get_completed_tasks: {e}")
        return []

def search_tasks(conn, user_id, pattern):
    try:
        q = re.sub(r'[^0-9a-zA-Zа-яА-ЯёЁ ]+', ' ', pattern).strip()
        if not q:
            logging.info(f"Invalid pattern for search tasks for user {user_id}")
            return []
        cur = conn.cursor()
        cur.execute("""SELECT l.title AS list_title, e.title AS task_title
                       FROM entities e
                       JOIN entities l ON l.id = e.parent_id
                       WHERE e.user_id=? AND e.type='task' AND LOWER(e.title) LIKE LOWER(?) AND (e.meta IS NULL OR json_extract(e.meta, '$.deleted') IS NOT TRUE AND json_extract(e.meta, '$.status') != 'done')
                       ORDER BY e.created_at ASC""", (user_id, f"%{q}%"))
        tasks = [(row["list_title"], row["task_title"]) for row in cur.fetchall()]
        logging.info(f"Found {len(tasks)} tasks matching '{q}' for user {user_id}: {tasks}")
        return tasks
    except sqlite3.Error as e:
        logging.error(f"SQLite error in search_tasks: {e}")
        return []

def fetch_task(conn, user_id, list_name, task_title):
    try:
        cur = conn.cursor()
        cur.execute("""SELECT e.id, e.title, e.meta FROM entities e
                       JOIN entities l ON l.id = e.parent_id
                       WHERE e.user_id=? AND e.type='task' AND l.type='list' AND l.title=? AND e.title=?
                       LIMIT 1""", (user_id, list_name, task_title))
        task = cur.fetchone()
        logging.info(f"Fetched task '{task_title}' from list '{list_name}' for user {user_id}: {'Found' if task else 'Not found'}")
        return task
    except sqlite3.Error as e:
        logging.error(f"SQLite error in fetch_task: {e}")
        return None

def fetch_list_by_task(conn, user_id, task_title):
    try:
        cur = conn.cursor()
        cur.execute("""SELECT l.title AS list_title, e.title AS task_title
                       FROM entities e
                       JOIN entities l ON l.id = e.parent_id
                       WHERE e.user_id=? AND e.type='task' AND e.title=?
                       LIMIT 1""", (user_id, task_title))
        result = cur.fetchone()
        logging.info(f"Fetched list by task '{task_title}' for user {user_id}: {'Found' if result else 'Not found'}")
        return result
    except sqlite3.Error as e:
        logging.error(f"SQLite error in fetch_list_by_task: {e}")
        return None

def move_entity(conn, user_id, entity_type, title, from_list, to_list):
    try:
        cur = conn.cursor()
        cur.execute("SELECT id FROM entities WHERE user_id=? AND type='list' AND title=? LIMIT 1", (user_id, from_list))
        from_row = cur.fetchone()
        if not from_row:
            logging.info(f"No list '{from_list}' found for user {user_id}")
            return 0
        from_list_id = from_row["id"]
        to_list_id = _get_or_create_list(conn, user_id, to_list)
        cur.execute("SELECT id FROM entities WHERE user_id=? AND type=? AND title=? AND parent_id=? LIMIT 1", 
                    (user_id, entity_type, title, from_list_id))
        entity = cur.fetchone()
        if not entity:
            logging.info(f"No {entity_type} '{title}' found in list '{from_list}' for user {user_id}")
            return 0
        cur.execute("UPDATE entities SET parent_id=? WHERE id=?", (to_list_id, entity["id"]))
        logging.info(f"Moved {entity_type} '{title}' from '{from_list}' to '{to_list}' for user {user_id}")
        return 1
    except sqlite3.Error as e:
        logging.error(f"SQLite error in move_entity: {e}")
        return 0

def get_all_tasks(conn, user_id):
    try:
        cur = conn.cursor()
        cur.execute("SELECT l.title AS list_title, e.title AS task_title FROM entities e JOIN entities l ON l.id = e.parent_id WHERE e.user_id=? AND e.type='task' AND (e.meta IS NULL OR json_extract(e.meta, '$.deleted') IS NOT TRUE AND json_extract(e.meta, '$.status') != 'done') ORDER BY l.title, e.created_at", (user_id,))
        tasks = [(row["list_title"], row["task_title"]) for row in cur.fetchall()]
        logging.info(f"Retrieved {len(tasks)} tasks for user {user_id}")
        return tasks
    except sqlite3.Error as e:
        logging.error(f"SQLite error in get_all_tasks: {e}")
        return []

def update_user_profile(conn, user_id, city=None, profession=None):
    try:
        meta = {"city": city, "profession": profession}
        cur = conn.cursor()
        cur.execute("INSERT OR REPLACE INTO entities (user_id, type, title, meta) VALUES (?, 'user_profile', ?, ?)", 
                    (user_id, f"user_{user_id}", json.dumps(meta, ensure_ascii=False)))
        logging.info(f"Updated user profile for user {user_id}: {meta}")
        return 1
    except sqlite3.Error as e:
        logging.error(f"SQLite error in update_user_profile: {e}")
        return 0

def get_user_profile(conn, user_id):
    try:
        cur = conn.cursor()
        cur.execute("SELECT meta FROM entities WHERE user_id=? AND type='user_profile' AND title=? LIMIT 1", 
                    (user_id, f"user_{user_id}"))
        row = cur.fetchone()
        if row and row["meta"]:
            return json.loads(row["meta"])
        return {}
    except sqlite3.Error as e:
        logging.error(f"SQLite error in get_user_profile: {e}")
        return {}

def delete_task_fuzzy(conn, user_id, list_name, pattern: str):
    try:
        if not pattern:
            logging.info(f"No pattern provided for fuzzy delete in list '{list_name}' for user {user_id}")
            return 0, None
        q = re.sub(r'[^0-9a-zA-Zа-яА-ЯёЁ ]+', ' ', pattern).strip()
        if not q:
            logging.info(f"Invalid pattern after cleaning for fuzzy delete in list '{list_name}' for user {user_id}")
            return 0, None
        cur = conn.cursor()
        cur.execute("""SELECT id FROM entities WHERE user_id=? AND type='list' AND title=? LIMIT 1""", (user_id, list_name))
        row = cur.fetchone()
        if not row:
            logging.info(f"No list '{list_name}' found for user {user_id}")
            return 0, None
        list_id = row["id"]
        cur.execute("""SELECT id, title, meta FROM entities WHERE user_id=? AND type='task' AND parent_id=? AND (meta IS NULL OR json_extract(meta, '$.deleted') IS NOT TRUE AND json_extract(meta, '$.status') != 'done')""", 
                    (user_id, list_id))
        candidates = [(r["id"], r["title"], r["meta"]) for r in cur.fetchall()]
        if not candidates:
            logging.info(f"No tasks found in list '{list_name}' for user {user_id}")
            return 0, None
        candidates.sort(key=lambda x: distance(x[1].lower(), q.lower()))
        if distance(candidates[0][1].lower(), q.lower()) > len(q) // 2:
            logging.info(f"No close match for pattern '{q}' in list '{list_name}' for user {user_id}")
            return 0, None
        chosen_id, chosen_title, meta = candidates[0]
        try:
            m = json.loads(meta) if meta else {}
        except:
            m = {}
        m["deleted"] = True
        cur.execute("UPDATE entities SET meta=? WHERE id=?", (json.dumps(m, ensure_ascii=False), chosen_id))
        logging.info(f"Fuzzy deleted task '{chosen_title}' from list '{list_name}' for user {user_id}")
        return 1, chosen_title
    except sqlite3.Error as e:
        logging.error(f"SQLite error in delete_task_fuzzy: {e}")
        return 0, None

def delete_task_by_index(conn, user_id, list_name: str, index: int):
    try:
        cur = conn.cursor()
        cur.execute("""SELECT id FROM entities WHERE user_id=? AND type='list' AND title=? LIMIT 1""", (user_id, list_name))
        row = cur.fetchone()
        if not row:
            logging.info(f"No list '{list_name}' found for user {user_id}")
            return 0, None
        list_id = row["id"]
        cur.execute("""SELECT id, title, meta FROM entities WHERE user_id=? AND type='task' AND parent_id=? AND (meta IS NULL OR json_extract(meta, '$.deleted') IS NOT TRUE AND json_extract(meta, '$.status') != 'done') ORDER BY created_at ASC""", 
                    (user_id, list_id))
        tasks = cur.fetchall()
        if not tasks or index < 1 or index > len(tasks):
            logging.info(f"Invalid index {index} for list '{list_name}' for user {user_id}")
            return 0, None
        chosen = tasks[index - 1]
        task_id, task_title, meta = chosen["id"], chosen["title"], chosen["meta"]
        try:
            m = json.loads(meta) if meta else {}
        except:
            m = {}
        m["deleted"] = True
        cur.execute("UPDATE entities SET meta=? WHERE id=?", (json.dumps(m, ensure_ascii=False), task_id))
        logging.info(f"Deleted task '{task_title}' by index {index} from list '{list_name}' for user {user_id}")
        return 1, task_title
    except sqlite3.Error as e:
        logging.error(f"SQLite error in delete_task_by_index: {e}")
        return 0, None

def normalize_text(value: str) -> str:
    if not value:
        return value
    value = value.strip()
    value = re.sub(r'\s+', ' ', value)
    value = value[:1].upper() + value[1:]
    value = re.sub(r'\bsp[oO]2\b', 'SPO2', value, flags=re.IGNORECASE)
    return value

def update_entity(conn, user_id: int, entity_type: str, title: str, new_title: str = None, new_content: str = None, meta_update: dict = None):
    cur = conn.cursor()
    updates = []
    params = []
    if new_title:
        updates.append("title = ?")
        params.append(new_title)
    if new_content:
        updates.append("content = ?")
        params.append(new_content)
    if meta_update:
        cur.execute("SELECT meta FROM entities WHERE user_id=? AND type=? AND title=?", (user_id, entity_type, title))
        row = cur.fetchone()
        if row:
            meta = json.loads(row[0] or "{}")
            meta.update(meta_update)
            updates.append("meta = ?")
            params.append(json.dumps(meta))
    if not updates:
        return None
    sql = f"UPDATE entities SET {", ".join(updates)} WHERE user_id=? AND type=? AND title=?"
    params.extend([user_id, entity_type, title])
    cur.execute(sql, params)
    conn.commit()
    return cur.rowcount > 0

def move_entity(conn, user_id: int, entity_type: str, title: str, new_parent_title: str):
    cur = conn.cursor()
    cur.execute("SELECT id FROM entities WHERE user_id=? AND type='list' AND title=?", (user_id, new_parent_title))
    new_parent = cur.fetchone()
    if not new_parent:
        return None
    new_parent_id = new_parent[0]
    cur.execute("UPDATE entities SET parent_id=? WHERE user_id=? AND type=? AND title=?", (new_parent_id, user_id, entity_type, title))
    conn.commit()
    return cur.rowcount > 0
